input {
     tcp {
     port => "12400"
  }
}


filter {
  mutate {
    add_field => {
      "[event][module]" => "cisco"
      "[event][dataset]" => "cisco.switch"
    }
  }
  mutate {
    strip => ["message"]
  }

  grok {
    tag_on_failure => "_parsefailure_header"
    match => { "message" => "(^(.*?)(<(?<pri>\d+)>)(\s)?(?<actual_msg>.*$))|(^(?<actual_msg>.*)$)" }
    timeout_millis => 500
  }
  syslog_pri {
    syslog_pri_field_name => "pri"
    remove_field => [ "pri" ]
  }

  if [log][source][hostname] {
    mutate {
      copy => { "[log][source][hostname]" => "[tmp][log_source_hostname]"}
    }
    mutate {
      split => { "[tmp][log_source_hostname]" => "." }
      add_field => { "[host][hostname]" => "%{[[tmp][log_source_hostname][0]]}"}
    }
  }

  mutate {
    id => "cisco-mutate-logoriginal1"
    add_field => {"[log][original]" => "%{[message]}"}
  }
  grok {
    id => "cisco.router-mutate-grok-actual_msg"
    match => {
      "actual_msg" => "^(?<[event][id]>.*?): (((?<[host][name]>.*?): )?(?<[tmp][device_timestamp]>.*): %(?<[tmp][facility]>.*?)-(?<[tmp][severity]>.*?)-(?<[tmp][mnemonic]>.*?): )?(?<[tmp][msg]>.*?)$"
    }
  }

  mutate {
    id => "cisco-mutate-gsub-date"
    gsub => [ "[tmp][ingest_timestamp]", "t", "-"]
  }
  date {
    id => "cisco-date-ingest"
    match => [
      "[tmp][ingest_timestamp]", "MMM dd yyyy HH:mm:ss",
      "MMM  d yyyy HH:mm:ss", "ISO8601", "yyyy-MM-dd-HH:mm:ss.SSSZ", "MMM dd HH:mm:ss.SSS", "MMM dd HH:mm:ss.SSS ZZZ", "MMM dd HH:mm:ss ZZZ", "MMM dd HH:mm:ss.SSS", "YYYY MMM dd HH:mm:ss.SSS ZZZ", "YYYY MMM dd HH:mm:ss ZZZ", "YYYY MMM dd HH:mm:ss.SSS"
    ]
    target => "[event][ingested]"
  }

  if [tmp][facility] and [tmp][mnemonic] {
    mutate {
      add_field => { "[event][action]" => "%{[[tmp][facility]]}.%{[[tmp][mnemonic]]}"}
    }
    mutate {
      lowercase => [ "[event][action]", "[tmp][msg]" ]
    }
  }

  translate {
    id => "cisco-translate-mnemonic"
    field => "[tmp][mnemonic]"
    destination => "[tmp][mnemonic_translation]"
    dictionary_path => "${LOGSTASH_HOME}/config/cisco_ios.json"
    refresh_interval => 3000
    fallback => '{"key1":"not_found"}'
  }


  if [tmp][mnemonic_translation] == '{"key1":"not_found"}' {
    json {
      source => "[tmp][mnemonic_translation]"
      target => "[tmp][mnemonic_translation]"
    }
    mutate {
      remove_field => ["[tmp][mnemonic_translation]"]
    }
    mutate {
      add_field => {
        "[tmp][mnemonic_translation][msg_explanation]" => "not_found_msg_explanation"
        "[tmp][mnemonic_translation][msg_recommendation]" => "not_found_msg_recommendation"
        "[tmp][mnemonic_translation][facility]" => "not_found_translation_facility"
        "[tmp][mnemonic_translation][msg_txt]" => "not_found_parsing_rule"
      }
    }
  }

  if [tmp][mnemonic_translation] {
    mutate {
      add_field => {
        "[event][reason]" => "%{[[tmp][mnemonic_translation][msg_explanation]]}"
        "[event][recommendation]" => "%{[[tmp][mnemonic_translation][msg_recommendation]]}"
        "[tmp][msg_parse]" => "%{[[tmp][mnemonic_translation][msg_txt]]}"
      }
    }
  }
  mutate {
    add_field => { "[error][message]" => "%{[[tmp][msg]]}"}
  }

  if [event][action] == "bgp.adjchange" {
    dissect {
      mapping => {
        "[tmp][msg]" => "neighbor %{[[tmp][related][ip]]} %{[[tmp][bgp][state]]} %{[[tmp][bgp][reason]]}"
      }
    }

    mutate {
      add_field => {
        "[event][type]" => "connection"
        "[event][category]" => "network"
        "[event][kind]" => "state"
      }
    }

    translate {
      field => "[tmp][bgp][state]"
      dictionary => [
      "down", "failure",
      "up", "success"
      ]
      exact => true
      fallback => "unknown"
      destination => "[event][outcome]"
    }
  }
  if [event][action] == "link.updown" {
    grok {
      id => "cisco.router-grok-link.updown"
      match => {
        "[tmp][msg]" => "%{GREEDYDATA}interface %{GREEDYDATA:[[tmp][ifname]]}\, changed state to %{WORD:[[tmp][interface][state]]}"
      }
      timeout_millis => 500
    }

    mutate {
      add_field => {
        "[event][type]" => "connection"
        "[event][category]" => "network"
        "[event][kind]" => "state"
        "[observer][ingress][interface][name]" => "%{[[tmp][ifname]]}"
        "[observer][ingress][interface][alias]" => "unknown_interface_alias"
      }
    }

    translate {
      field => "[tmp][interface][state]"
      dictionary => [
      "down", "failure",
      "up", "success"
      ]
      exact => true
      fallback => "unknown"
      destination => "[event][outcome]"
    }
  }
  if [event][action] == "line.updown" {
    grok {
      id => "cisco.router-grok-line.updown"
      match => {
        "[tmp][msg]" => "line protocol on interface %{GREEDYDATA:[[tmp][ifname]]}, changed state to %{WORD:[[tmp][interface][state]]}"
      }
      timeout_millis => 500
    }

    mutate {
      add_field => {
        "[event][type]" => "connection"
        "[event][category]" => "network"
        "[event][kind]" => "state"
        "[observer][ingress][interface][name]" => "%{[[tmp][ifname]]}"
        "[observer][ingress][interface][alias]" => "unknown_interface_alias"
      }
    }

    translate {
      field => "[tmp][interface][state]"
      dictionary => [
      "down", "failure",
      "up", "success"
      ]
      exact => true
      fallback => "unknown"
      destination => "[event][outcome]"
    }
  }
}
output {
  stdout { codec => rubydebug }
}
